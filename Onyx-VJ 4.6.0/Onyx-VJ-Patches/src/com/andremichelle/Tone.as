package com.andremichelle{	import library.patches.ToneWheelApplication;
	/**	 * @author aM	 */	public class Tone		implements IToneGenerator	{		private var _delta: int;				private var _numDecay: Number;				private var _phase: Number;		private var _phaseIncr: Number;				private var _gainL: Number;		private var _gainR: Number;				public function Tone( delta: int, note: uint, octave: uint, pan: Number )		{			_delta = delta;						_numDecay = 20000;						_phase = 0.0;			_phaseIncr = 110.0 * Math.pow( 2, octave + note / 12 ) / 44100;			var volume: Number = 1 / ( 1 + Math.abs( pan ) );						_gainL = ( 1 - pan ) * volume;			_gainR = ( pan + 1 ) * volume;		}		public function processAudioAdd( buffer: Vector.<Vector.<Number>> ): Boolean		{			var amplitude: Number;						var env: Number;			var tmp: Number;						var l: Vector.<Number> = buffer[0];			var r: Vector.<Number> = buffer[1];						for( var i: int = _delta ; i < ToneWheelApplication.BUFFER_SIZE ; ++i )			{				env = _numDecay / 20000;								if( _phase < .5 )				{					tmp = ( _phase * 4.0 - 1.0 );					amplitude = ( 1.0 - tmp * tmp ) * env * env * .5;				}				else				{					tmp = ( _phase * 4.0 - 3.0 );					amplitude = ( tmp * tmp - 1.0 ) * env * env * .5;				}				_phase += _phaseIncr;								if( _phase >= 1 ) --_phase;								l[i] += amplitude * _gainL;				r[i] += amplitude * _gainR;				if( --_numDecay == 0 )					return true;			}						_delta = 0;						return false;		}	}}